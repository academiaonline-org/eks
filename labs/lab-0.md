The sample application for these workshop labs mirrors a basic web store, providing practical container components for our exercises. The application is designed to imitate a typical online shopping experience.

Here's an overview of the functionalities it offers:

1. **Product Catalog**: This feature allows customers to explore various products. It lists all the available products along with their details, making it easier for the customer to find what they need.

2. **Shopping Cart**: This is where the chosen items are collected. Customers can add or remove items from their cart as per their preferences. The cart updates in real time, giving customers control over their potential purchase.

3. **Checkout Process**: Once customers are ready with their selection, they can move to the checkout process. Here they review their cart, provide shipping information, and complete the payment to finalize their order.

The goal of using this sample application is to offer a realistic environment for understanding and experimenting with container components. The variety of features mimic those you would expect to encounter in a professional development project. It serves to make the workshop exercises both educational and relatable to real-world application development.

* https://github.com/aws-containers/retail-store-sample-app

Before deploying a workload to a Kubernetes distribution like EKS, it must be packaged as a container image and published to a container registry. While this workshop doesn't cover basic container topics, rest assured that the sample application has container images readily available in Amazon Elastic Container Registry (ECR) for the labs we'll tackle today.

The table below offers links to the ECR Public repository for each component of our sample application, alongside the Dockerfile used to build each one. The Dockerfiles serve as a guide to how the container images were built, and the ECR Public repositories store the ready-to-use images.

| Component | ECR Public Repository | Dockerfile |
| ----------- | ------------------------ | ------------ |
| UI          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-ui) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/images/java17/Dockerfile) |
| Catalog          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-catalog) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/images/go/Dockerfile) |
| Shopping cart          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-cart) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/images/java17/Dockerfile) |
| Checkout          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-checkout) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/images/nodejs/Dockerfile) |
| Orders          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-orders) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/images/java17/Dockerfile) |
| Assets          | [Repository](https://gallery.ecr.aws/aws-containers/retail-store-sample-assets) | [Dockerfile](https://github.com/aws-containers/retail-store-sample-app/blob/main/src/assets/Dockerfile) |

By providing these resources, we ensure you have all the necessary tools at your disposal for a smooth and effective workshop experience.

Now that we have a good understanding of the sample application's overall structure, how do we go about its initial deployment into EKS? Let's delve into some of the fundamental elements of Kubernetes by examining the catalog component:
* https://www.eksworkshop.com/assets/images/catalog-microservice-450d6b2c9455ae06ae050a332de816be.png

There are several elements to keep in mind in this diagram:
* The application that delivers the catalog API operates as a Pod, the smallest deployable unit in Kubernetes. The Pods running for the catalog component are generated by a Deployment, which manages one or more "replicas" of the catalog Pod, thereby enabling horizontal scaling.
* The application Pods run the container images we previously discussed.
* A Service provides an abstract way to expose an application running as a set of Pods, allowing our catalog API to be accessed by other components within the Kubernetes cluster. Each Service is assigned its own DNS entry.
* At the start of this workshop, we have a MySQL database that operates within our Kubernetes cluster as a StatefulSet, specifically designed to manage stateful workloads.
* All these Kubernetes constructs are organized within their own dedicated catalog Namespace. Each of the application components has its own Namespace.

Each component in the microservices architecture resembles the catalog in a conceptual sense, using Deployments to manage application workload Pods and Services to route traffic to those Pods. When we widen our view of the architecture, we can contemplate how traffic is directed throughout the broader system:
* https://www.eksworkshop.com/assets/images/microservices-da8ae7db8227d536d2481f4bfe5248e2.png

The UI component processes HTTP requests from sources such as a user's browser. It then sends HTTP requests to other API components within the architecture to handle that request and delivers a response back to the user. Each of the downstream components might have their own data storage or other infrastructure. The Namespaces serve as a logical grouping for the resources of each microservice and also function as a soft isolation boundary. This can be effectively utilized to implement controls using Kubernetes RBAC and Network Policies.

The sample application consists of a set of Kubernetes manifests arranged in a manner that can be readily applied with Kustomize. Kustomize is an open-source tool that's also included as a native feature of the kubectl CLI. In this workshop, we use Kustomize to apply modifications to Kubernetes manifests, simplifying the comprehension of changes to manifest files without the need for manual YAML editing. As we proceed through the various modules of this workshop, we'll incrementally apply overlays and patches using Kustomize.

The simplest way to browse the YAML manifests for the sample application and the modules in this workshop is through the file browser in Cloud9. By expanding the workspace directory followed by the manifests directory, you'll see all of the components of the sample application:
* https://www.eksworkshop.com/assets/images/cloud9-files-14237ddd6ccd963e657758ca8b1ab53c.png

